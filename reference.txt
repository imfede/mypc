00 00 AA BB  MV AA, BB       move from register BB to register AA

00 01 00 AA: MEMR AA         read from memory location to register AA
00 01 01 AA: MEMW AA         write to memory location from register AA
00 01 10 AA: MSRL AA         set memory register low from register AA
00 01 11 AA: MSRH AA         set memory register high from register AA

00 10 00 AA: LI AA, 0xAB     read next instruction as data into register AA
00 10 01 AA: ZERO AA         set content of register AA as 0x00
00 10 10 
00 10 11

01 00 AA BB: ADD AA, BB      AA = AA + BB
01 01 AA BB: SUB AA, BB      AA = AA - BB
01 10 AA BB: NAND AA, BB     AA = AA NAND BB
01 11 AA BB: XOR AA, BB      AA = AA XOR BB

10 00 00 AA: ADDI AA, 0xAB   AA = AA + 0xAB
10 00 01 AA: INC AA          AA = AA + 1
10 00 10 AA: DEC AA          AA = AA - 1
10 00 11 AA: NEG AA          AA = -AA

11 00 00 00: JMP 0xAB, 0xCD  set IP to 0xABCD
11 00 00 01
11 00 00 10
11 00 00 11

11 00 01 00: JCR 0x12        if carry jump around      
11 00 01 01: JZR 0x12        if negative jump around
11 00 01 10: JNR 0x12        if negative jump around
11 00 01 11: JLTR 0x12       if A1 < A2 jump around

11 01

11 10

11 11 00 AA: SPSL AA
11 11 01 AA: SPSH AA

# the stack grows toward lesser addressed
11 11 10 00: PUSH            set memory register to SP and advance (decrement) SP
11 11 10 01: PULL            retreat (increment) SP and set memory register to SP
11 11 10 10: PEEK            set memory register to SP
11 11 10 11

11 11 11 00
11 11 11 01
11 11 11 10
11 11 11 11: HLT 